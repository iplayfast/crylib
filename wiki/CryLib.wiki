#summary Intro to the Library
#labels Featured,Phase-Implementation

= Introduction =

Crylib is an object oriented library based on the idea that all classes eventually have as their base class Object.

= Details =

Object doesn't normally contain any data although it can contain an ObjectID if DEBUG is defined. Object instead defines all the interfaces of the classes that inherit from it. 

Object itself inherits from EmptyObject which is simply
struct EmptyObject {};

No data, no functions just a name to hang your code on. 

Each class also has a #define of it's class name. The name is the letter C plus the name of the class, so for instance Object is CObject, String is CString.

Some of the functions which Object defines are

{{{
   const char* ClassName() const;
}}}
This function a pointer to a string stating the current class Name. For example Object (not String which would be a child class)

{{{
    virtual const char *ChildClassName() const;
}}}
This function returns a pointer to a string stating the ChildClassName, For exampleEG CryString (not Object which is the base class)

To illustrate this consider the following code:
{{{
String a;
Object *o = &a;
const char *ClassName = o->ClassName();  // returns "Object"
const char *ChildClassName = o->ChildClassName(); // returns "String"
}}}

Often a class is passed using the least common denomintator (ie Object) so these functions are useful to find out what type of class you are dealing with.

{{{
    virtual bool IsA(const char *ClassName) const;    // can the object map to a ClassName
}}}
IsA is another useful function for finding out if a class inherits from another.  

{{{
String a;
   a->IsA(CObject); // returns true
   a->IsA(XML);  // returns false
}}}

{{{
     virtual bool CanDup() const;
}}}
Which asks can this function duplicate itself? This is useful for sub-classes which may not be able to duplicate. eg a file stream class.

{{{
    virtual void CopyTo(Object &Dest) const;
}}}
Which copies the data of the current object (or class derived from it) to the Object Dest.  This obviously must make sense for the object, but for the most part it works as you would expect. You couldn't for example, copy a string to a neural net and expect the classes to know what to do with it, but you could copy a neural net to an XML class, and copy the XML class to the string, (and do the reverse as well).

{{{
    const char *GetProperty(const char *PropertyName,String &Result) const;
}}}
GetProperty will return a const char * and a Result showing the property's value, usually the const char * will point to the first character of the Result, however in the case of a property that is an array, the returned const char * will point to a "*", and the result will return a "[]"
String for example has:
1. property "Value" which has the value of whatever the string contains.
2. property "Terminator" which has the value of the terminating character (usually '\0')
3. When DEBUG is defined property "ObjectID" which has the number representing this object.


{{{
    virtual const cbyte* GetRaw() const;
}}}
This is the backdoor to get at data. For string it returns the characters in the string. Sometimes it's just easier to use the backdoor then the front.

{{{
   virtual int Compare(int CompareType,const Object *Test1,const Object *Test2) const;
}}}
Will return a value showing a comparison result using CompareType. Used by derived classes
in order to have comparisons which makes sense to the class.  CompareType is used to allow different types of comparisons within a class.
Other compare functions abound
{{{
	virtual int CompareLogical(int CompareType,const Object *Test) const;

    /// returns bool value of LessThen as determined by CompareLogical
    virtual bool LessThen(int CompareType,const Object *Test) const;

	/// returns bool value of GreaterThen as determined by CompareLogical
	virtual bool GreaterThen(int CompareType,const Object *Test) const;

	/// returns bool value of EqualTo as determined by CompareLogical
	virtual bool EqualTo(int CompareType,const Object *Test) const;
}}}

{{{
    virtual bool IsContainer() const;
}}}
IsContainer is true when the object in question can contain accessable instances of data or objects.IE Streams are not containers, but lists and arrays are.
    

This is just a small taste of the functionality available with this class system. It is by no means complete, but is already useful. 